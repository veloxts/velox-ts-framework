---
title: Procedures
description: The core abstraction for defining type-safe API endpoints.
---

import { Aside } from '@astrojs/starlight/components';

Procedures are the core building block of VeloxTS APIs. They define type-safe endpoints with input validation, output schemas, and handlers.

## Basic Syntax

```typescript
import { procedures, procedure, resourceSchema, resource } from '@veloxts/velox';
import { z } from '@veloxts/velox';

// Define resource schema with field visibility
const UserSchema = resourceSchema()
  .public('id', z.string().uuid())
  .public('name', z.string())
  .authenticated('email', z.string().email())
  .admin('internalNotes', z.string().nullable())
  .build();

export const userProcedures = procedures('users', {
  getUser: procedure()
    .input(z.object({ id: z.string() }))
    .query(async ({ input, ctx }) => {
      const user = await ctx.db.user.findUniqueOrThrow({
        where: { id: input.id }
      });
      return resource(user, UserSchema.public); // returns { id, name }
    }),
});
```

<Aside type="caution" title="Common Mistake">
Use `procedure()` with parentheses to create a new builder instance:

```typescript
// Correct
getUser: procedure().input(...).query(...)

// Wrong - creates shared state issues
getUser: procedure.input(...).query(...)
```
</Aside>

## Builder Methods

### `.input(schema)`

Define the input validation schema:

```typescript
.input(z.object({
  id: z.string().uuid(),
  includeDeleted: z.boolean().optional(),
}))
```

### `.resource(schema)`

Attach a resource schema for context-dependent output projection. The Resource API lets you define field visibility levels (`public`, `authenticated`, `admin`) once and project data based on access level.

```typescript
const UserSchema = resourceSchema()
  .public('id', z.string())
  .public('name', z.string())
  .authenticated('email', z.string())
  .admin('internalNotes', z.string().nullable())
  .build();

// Tagged view â€” one-liner projection
getPublicProfile: procedure()
  .query(async ({ input, ctx }) => {
    const user = await ctx.db.user.findUniqueOrThrow({ where: { id: input.id } });
    return resource(user, UserSchema.public); // returns { id, name }
  }),

// Automatic projection with guards
getProfile: procedure()
  .guardNarrow(authenticatedNarrow)
  .resource(UserSchema) // auto-projects { id, name, email }
  .query(async ({ input, ctx }) => {
    return ctx.db.user.findUniqueOrThrow({ where: { id: input.id } });
  }),
```

See [Resource API](/docs/endpoints/resource-api/) for tagged views, automatic projection, manual projection, collections, and type inference.

### `.query(handler)` / `.mutation(handler)`

Define the handler function:

- `.query()` - For read operations (GET)
- `.mutation()` - For write operations (POST, PUT, DELETE)

```typescript
.query(({ input, ctx }) => ctx.db.user.findUniqueOrThrow({
  where: { id: input.id }
}))
```

### `.guard(guardFn)`

Add authorization guards:

```typescript
.guard(authenticated)
.guard(hasRole('admin'))
```

### `.use(middleware)`

Add middleware:

```typescript
.use(rateLimitMiddleware)
.use(loggingMiddleware)
```

### `.rest(options)`

Override REST endpoint generation:

```typescript
.rest({ method: 'POST', path: '/auth/login' })
```

See [REST Overrides](/docs/router/rest-overrides/) for full options.

## Method Chain Order

<Aside type="caution" title="Builder Chain Order Matters">
Methods must be called in this order:

```typescript
procedure()
  .input(schema)       // 1. Input validation (optional)
  .guard(guardFn)      // 2. Authorization (optional, can have multiple)
  .guardNarrow(guard)  // 2b. Narrowing guard (optional, sets access level)
  .resource(schema)    // 3. Resource schema for auto-projection (optional)
  .use(middleware)     // 4. Middleware (optional, can have multiple)
  .rest(options)       // 5. REST override (optional) - BEFORE handler
  .query(handler)      // 6. Handler - MUST be last
```

**Wrong:**
```typescript
// ERROR: .rest() after .query() won't work
procedure().query(handler).rest(options)
```
</Aside>

## Handler Context

The handler receives `{ input, ctx }`:

```typescript
.query(({ input, ctx }) => {
  // input: Validated input data
  // ctx.db: Prisma client
  // ctx.request: Fastify request
  // ctx.reply: Fastify reply
  // ctx.user: Authenticated user (if using auth)
})
```

## Procedure Collections

Group related procedures with `procedures()`:

```typescript
export const postProcedures = procedures('posts', {
  listPosts: procedure()...,
  getPost: procedure()...,
  createPost: procedure()...,
  updatePost: procedure()...,
  deletePost: procedure()...,
});
```

The first argument (`'posts'`) becomes:
- The REST resource name: `/api/posts`
- The tRPC namespace: `trpc.posts.listPosts`

## Type Inference

Types flow automatically through the Resource API:

```typescript
// Backend - Define resource schema
const UserSchema = resourceSchema()
  .public('id', z.string())
  .public('name', z.string())
  .authenticated('email', z.string())
  .build();

const createUser = procedure()
  .input(z.object({ name: z.string(), email: z.string().email() }))
  .mutation(async ({ input, ctx }) => {
    const user = await ctx.db.user.create({ data: input });
    return resource(user, UserSchema.authenticated);
  });

// Frontend (via tRPC or client)
// Input is typed: { name: string; email: string }
// Output is typed: { id: string; name: string; email: string }
```

## Discovery

Procedures are automatically discovered from `src/procedures/`:

```typescript
// src/index.ts
import { veloxApp, rest, discoverProcedures } from '@veloxts/velox';

const app = await veloxApp({ port: 3030 });
const collections = await discoverProcedures('./src/procedures');
app.routes(rest([...collections], { prefix: '/api' }));
```

## Related Content

- [Resource API](/docs/endpoints/resource-api/) - Field-level visibility and projection
- [REST Conventions](/docs/router/rest-conventions/) - How names map to HTTP
- [Guards](/docs/authentication/guards/) - Authorization
- [Middleware](/docs/router/middleware/) - Request processing

---
title: Procedures
description: The core abstraction for defining type-safe API endpoints.
---

import { Aside } from '@astrojs/starlight/components';

Procedures are the core building block of VeloxTS APIs. They define type-safe endpoints with input validation, output schemas, and handlers.

## Basic Syntax

```typescript
import { procedures, procedure, resourceSchema, resource } from '@veloxts/velox';
import { z } from '@veloxts/velox';

// Define resource schema with field visibility
const UserSchema = resourceSchema()
  .public('id', z.string().uuid())
  .public('name', z.string())
  .authenticated('email', z.string().email())
  .admin('internalNotes', z.string().nullable())
  .build();

export const userProcedures = procedures('users', {
  getUser: procedure()
    .input(z.object({ id: z.string() }))
    .query(async ({ input, ctx }) => {
      const user = await ctx.db.user.findUniqueOrThrow({
        where: { id: input.id }
      });
      return resource(user, UserSchema).forAnonymous();
    }),
});
```

<Aside type="caution" title="Common Mistake">
Use `procedure()` with parentheses to create a new builder instance:

```typescript
// Correct
getUser: procedure().input(...).query(...)

// Wrong - creates shared state issues
getUser: procedure.input(...).query(...)
```
</Aside>

## Builder Methods

### `.input(schema)`

Define the input validation schema:

```typescript
.input(z.object({
  id: z.string().uuid(),
  includeDeleted: z.boolean().optional(),
}))
```

### Resource API

Define context-dependent outputs using the Resource API:

```typescript
// Define a resource schema with field visibility
const UserSchema = resourceSchema()
  .public('id', z.string())
  .public('name', z.string())
  .authenticated('email', z.string())
  .admin('internalNotes', z.string().nullable())
  .build();

// In your procedure handler, use resource() to project fields
.query(async ({ input, ctx }) => {
  const user = await ctx.db.user.findUnique({ where: { id: input.id } });

  // Return only public fields for anonymous users
  return resource(user, UserSchema).forAnonymous();

  // Or authenticated fields for logged-in users
  // return resource(user, UserSchema).forAuthenticated();

  // Or all fields for admins
  // return resource(user, UserSchema).forAdmin();
})
```

See [Validation > Schemas](/docs/validation/schemas/) for detailed Resource API documentation.

### `.query(handler)` / `.mutation(handler)`

Define the handler function:

- `.query()` - For read operations (GET)
- `.mutation()` - For write operations (POST, PUT, DELETE)

```typescript
.query(({ input, ctx }) => ctx.db.user.findUniqueOrThrow({
  where: { id: input.id }
}))
```

### `.guard(guardFn)`

Add authorization guards:

```typescript
.guard(authenticated)
.guard(hasRole('admin'))
```

### `.use(middleware)`

Add middleware:

```typescript
.use(rateLimitMiddleware)
.use(loggingMiddleware)
```

### `.rest(options)`

Override REST endpoint generation:

```typescript
.rest({ method: 'POST', path: '/auth/login' })
.rest({ enabled: false })  // tRPC-only
```

See [REST Overrides](/docs/router/rest-overrides/) for full options.

## Method Chain Order

<Aside type="caution" title="Builder Chain Order Matters">
Methods must be called in this order:

```typescript
procedure()
  .input(schema)       // 1. Input validation (optional)
  .guard(guardFn)      // 2. Authorization (optional, can have multiple)
  .use(middleware)     // 3. Middleware (optional, can have multiple)
  .rest(options)       // 4. REST override (optional) - BEFORE handler
  .query(handler)      // 5. Handler - MUST be last (use Resource API inside)
```

**Wrong:**
```typescript
// ERROR: .rest() after .query() won't work
procedure().query(handler).rest(options)
```
</Aside>

## Handler Context

The handler receives `{ input, ctx }`:

```typescript
.query(({ input, ctx }) => {
  // input: Validated input data
  // ctx.db: Prisma client
  // ctx.request: Fastify request
  // ctx.reply: Fastify reply
  // ctx.user: Authenticated user (if using auth)
})
```

## Procedure Collections

Group related procedures with `procedures()`:

```typescript
export const postProcedures = procedures('posts', {
  listPosts: procedure()...,
  getPost: procedure()...,
  createPost: procedure()...,
  updatePost: procedure()...,
  deletePost: procedure()...,
});
```

The first argument (`'posts'`) becomes:
- The REST resource name: `/api/posts`
- The tRPC namespace: `trpc.posts.listPosts`

## Type Inference

Types flow automatically through the Resource API:

```typescript
// Backend - Define resource schema
const UserSchema = resourceSchema()
  .public('id', z.string())
  .public('name', z.string())
  .authenticated('email', z.string())
  .build();

const createUser = procedure()
  .input(z.object({ name: z.string(), email: z.string().email() }))
  .mutation(async ({ input, ctx }) => {
    const user = await ctx.db.user.create({ data: input });
    return resource(user, UserSchema).forAuthenticated();
  });

// Frontend (via tRPC or client)
// Input is typed: { name: string; email: string }
// Output is typed: { id: string; name: string; email: string }
```

## Discovery

Procedures are automatically discovered from `src/procedures/`:

```typescript
// src/index.ts
import { veloxApp, rest, discoverProcedures } from '@veloxts/velox';

const app = await veloxApp({ port: 3030 });
const collections = await discoverProcedures('./src/procedures');
app.routes(rest([...collections], { prefix: '/api' }));
```

## Related Content

- [REST Conventions](/docs/router/rest-conventions/) - How names map to HTTP
- [Guards](/docs/authentication/guards/) - Authorization
- [Middleware](/docs/router/middleware/) - Request processing

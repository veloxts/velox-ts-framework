---
title: Procedures
description: The core abstraction for defining type-safe API endpoints.
---

import { Aside } from '@astrojs/starlight/components';

Procedures are the core building block of VeloxTS APIs. They define type-safe endpoints with input validation, output schemas, and handlers.

## Basic Syntax

```typescript
import { procedures, procedure, resourceSchema, resource } from '@veloxts/velox';
import { z } from '@veloxts/velox';

// Define resource schema with field visibility
const UserSchema = resourceSchema()
  .public('id', z.string().uuid())
  .public('name', z.string())
  .authenticated('email', z.string().email())
  .admin('internalNotes', z.string().nullable())
  .build();

export const userProcedures = procedures('users', {
  getUser: procedure()
    .input(z.object({ id: z.string() }))
    .query(async ({ input, ctx }) => {
      const user = await ctx.db.user.findUniqueOrThrow({
        where: { id: input.id }
      });
      return resource(user, UserSchema).forAnonymous();
    }),
});
```

<Aside type="caution" title="Common Mistake">
Use `procedure()` with parentheses to create a new builder instance:

```typescript
// Correct
getUser: procedure().input(...).query(...)

// Wrong - creates shared state issues
getUser: procedure.input(...).query(...)
```
</Aside>

## Builder Methods

### `.input(schema)`

Define the input validation schema:

```typescript
.input(z.object({
  id: z.string().uuid(),
  includeDeleted: z.boolean().optional(),
}))
```

### `.resource(schema)`

#### Resource API

The Resource API enables **context-dependent outputs** - returning different fields based on the caller's access level (anonymous, authenticated, or admin). This solves the problem of over-fetching sensitive data while maintaining type safety.

**Key concept:** Instead of defining a single output schema, you define field visibility levels. The API automatically filters fields based on who's calling.

```typescript
const UserSchema = resourceSchema()
  .public('id', z.string())           // Everyone sees this
  .public('name', z.string())         // Everyone sees this
  .authenticated('email', z.string()) // Only logged-in users
  .admin('internalNotes', z.string().nullable()) // Only admins
  .build();
```

#### Automatic Projection (Simple Cases)

Chain `.guardNarrow()` with `.resource()` for automatic field projection. The procedure executor reads the guard's `accessLevel` and projects fields automatically.

<Aside type="tip" title="Why guardNarrow?">
Use `.guardNarrow()` instead of `.guard()` to get **TypeScript type narrowing**. After `guardNarrow(authenticatedNarrow)`, TypeScript knows `ctx.user` is non-null - no more `ctx.user?.email` checks needed.

Both methods work for runtime auto-projection, but only `.guardNarrow()` improves your types.
</Aside>

```typescript
import { authenticatedNarrow, adminNarrow } from '@veloxts/auth';

// Authenticated endpoint - auto-projects { id, name, email }
getProfile: procedure()
  .guardNarrow(authenticatedNarrow)
  .resource(UserSchema)
  .input(z.object({ id: z.string() }))
  .query(async ({ input, ctx }) => {
    // ctx.user is guaranteed non-null (TypeScript knows this!)
    // Just return data - projection happens automatically
    return ctx.db.user.findUniqueOrThrow({ where: { id: input.id } });
  }),

// Admin endpoint - auto-projects all fields including internalNotes
getFullProfile: procedure()
  .guardNarrow(adminNarrow)
  .resource(UserSchema)
  .input(z.object({ id: z.string() }))
  .query(async ({ input, ctx }) => {
    return ctx.db.user.findUniqueOrThrow({ where: { id: input.id } });
  }),
```

#### Manual Projection (Complex Cases)

For public endpoints (no guard) or conditional logic, use explicit `.forX()` methods:

```typescript
import { resource } from '@veloxts/router';

// Public endpoint - no guard, must project manually
getPublicProfile: procedure()
  .input(z.object({ id: z.string() }))
  .query(async ({ input, ctx }) => {
    const user = await ctx.db.user.findUnique({ where: { id: input.id } });
    return resource(user, UserSchema).forAnonymous();
  }),

// Conditional projection - different output based on ownership
getOwnProfile: procedure()
  .guard(authenticated)
  .input(z.object({ id: z.string() }))
  .query(async ({ input, ctx }) => {
    const user = await ctx.db.user.findUnique({ where: { id: input.id } });
    // Show more fields if viewing own profile
    if (user.id === ctx.user?.id) {
      return resource(user, UserSchema).forAuthenticated();
    }
    return resource(user, UserSchema).forAnonymous();
  }),
```

See [Validation > Schemas](/docs/validation/schemas/) for detailed Resource API documentation.

### `.query(handler)` / `.mutation(handler)`

Define the handler function:

- `.query()` - For read operations (GET)
- `.mutation()` - For write operations (POST, PUT, DELETE)

```typescript
.query(({ input, ctx }) => ctx.db.user.findUniqueOrThrow({
  where: { id: input.id }
}))
```

### `.guard(guardFn)`

Add authorization guards:

```typescript
.guard(authenticated)
.guard(hasRole('admin'))
```

### `.use(middleware)`

Add middleware:

```typescript
.use(rateLimitMiddleware)
.use(loggingMiddleware)
```

### `.rest(options)`

Override REST endpoint generation:

```typescript
.rest({ method: 'POST', path: '/auth/login' })
.rest({ enabled: false })  // tRPC-only
```

See [REST Overrides](/docs/router/rest-overrides/) for full options.

## Method Chain Order

<Aside type="caution" title="Builder Chain Order Matters">
Methods must be called in this order:

```typescript
procedure()
  .input(schema)       // 1. Input validation (optional)
  .guard(guardFn)      // 2. Authorization (optional, can have multiple)
  .guardNarrow(guard)  // 2b. Narrowing guard (optional, sets access level)
  .resource(schema)    // 3. Resource schema for auto-projection (optional)
  .use(middleware)     // 4. Middleware (optional, can have multiple)
  .rest(options)       // 5. REST override (optional) - BEFORE handler
  .query(handler)      // 6. Handler - MUST be last
```

**Wrong:**
```typescript
// ERROR: .rest() after .query() won't work
procedure().query(handler).rest(options)
```
</Aside>

## Handler Context

The handler receives `{ input, ctx }`:

```typescript
.query(({ input, ctx }) => {
  // input: Validated input data
  // ctx.db: Prisma client
  // ctx.request: Fastify request
  // ctx.reply: Fastify reply
  // ctx.user: Authenticated user (if using auth)
})
```

## Procedure Collections

Group related procedures with `procedures()`:

```typescript
export const postProcedures = procedures('posts', {
  listPosts: procedure()...,
  getPost: procedure()...,
  createPost: procedure()...,
  updatePost: procedure()...,
  deletePost: procedure()...,
});
```

The first argument (`'posts'`) becomes:
- The REST resource name: `/api/posts`
- The tRPC namespace: `trpc.posts.listPosts`

## Type Inference

Types flow automatically through the Resource API:

```typescript
// Backend - Define resource schema
const UserSchema = resourceSchema()
  .public('id', z.string())
  .public('name', z.string())
  .authenticated('email', z.string())
  .build();

const createUser = procedure()
  .input(z.object({ name: z.string(), email: z.string().email() }))
  .mutation(async ({ input, ctx }) => {
    const user = await ctx.db.user.create({ data: input });
    return resource(user, UserSchema).forAuthenticated();
  });

// Frontend (via tRPC or client)
// Input is typed: { name: string; email: string }
// Output is typed: { id: string; name: string; email: string }
```

## Discovery

Procedures are automatically discovered from `src/procedures/`:

```typescript
// src/index.ts
import { veloxApp, rest, discoverProcedures } from '@veloxts/velox';

const app = await veloxApp({ port: 3030 });
const collections = await discoverProcedures('./src/procedures');
app.routes(rest([...collections], { prefix: '/api' }));
```

## Related Content

- [REST Conventions](/docs/router/rest-conventions/) - How names map to HTTP
- [Guards](/docs/authentication/guards/) - Authorization
- [Middleware](/docs/router/middleware/) - Request processing

---
title: Session Authentication
description: Cookie-based session authentication.
---

Session authentication stores state server-side, using cookies for identification.

## Setup

```typescript
import { sessionMiddleware, inMemorySessionStore } from '@veloxts/auth';

const session = sessionMiddleware({
  secret: process.env.SESSION_SECRET!,
  store: inMemorySessionStore(), // Use Redis in production
  cookie: {
    name: 'session',
    secure: true,
    httpOnly: true,
    sameSite: 'lax',
    maxAge: 86400, // 24 hours
  },
});
```

## Login Flow

```typescript
login: procedure()
  .use(session.optionalAuth())
  .input(LoginSchema)
  .mutation(async ({ input, ctx }) => {
    const user = await verifyCredentials(input);

    // Create session (regenerates session ID to prevent fixation)
    await ctx.session.login({
      id: user.id,
      email: user.email,
    });

    return { user };
  }),
```

## Logout

```typescript
logout: procedure()
  .use(session.requireAuth())
  .mutation(async ({ ctx }) => {
    await ctx.session.logout();
    return { success: true };
  }),
```

## Protecting Routes

```typescript
getProfile: procedure()
  .use(session.requireAuth())
  .query(({ ctx }) => ctx.user),

// Optional auth (user may or may not be logged in)
homePage: procedure()
  .use(session.optionalAuth())
  .query(({ ctx }) => ({ user: ctx.user ?? null })),
```

## Flash Messages

```typescript
// Set flash message
ctx.session.flash('success', 'Profile updated!');

// Read flash message (one-time)
const message = ctx.session.getFlash('success');
```

## Production: Custom Store

For production, implement the `SessionStore` interface with Redis or another persistent store:

```typescript
import type { SessionStore, StoredSession } from '@veloxts/auth';
import Redis from 'ioredis';

function createRedisStore(redis: Redis): SessionStore {
  return {
    async get(id: string): Promise<StoredSession | null> {
      const data = await redis.get(`session:${id}`);
      return data ? JSON.parse(data) : null;
    },
    async set(id: string, session: StoredSession, ttl: number): Promise<void> {
      await redis.setex(`session:${id}`, ttl, JSON.stringify(session));
    },
    async destroy(id: string): Promise<void> {
      await redis.del(`session:${id}`);
    },
    async touch(id: string, ttl: number): Promise<void> {
      await redis.expire(`session:${id}`, ttl);
    },
  };
}

const session = sessionMiddleware({
  store: createRedisStore(new Redis(process.env.REDIS_URL)),
  // ...
});
```

## Related Content

- [JWT](/docs/authentication/jwt/) - Alternative approach
- [Guards](/docs/authentication/guards/) - Authorization

---
title: Hybrid Architecture
description: Combine REST and tRPC for different client needs.
---

Use this architecture when you have both TypeScript and non-TypeScript clients.

## When to Choose Hybrid

- Mobile apps (REST) + web dashboard (tRPC)
- Public API (REST) + internal tools (tRPC)
- Gradual migration from REST to tRPC
- Different teams with different needs

## How It Works

VeloxTS generates both REST and tRPC endpoints from the same procedures:

```typescript
import { resourceSchema, resourceCollection } from '@veloxts/router';

const OrderSchema = resourceSchema()
  .public('id', z.string())
  .public('total', z.number())
  .authenticated('userId', z.string())
  .admin('paymentDetails', z.object({ /* ... */ }))
  .build();

export const orderProcedures = procedures('orders', {
  // Available as:
  // - REST: GET /api/orders
  // - tRPC: trpc.orders.listOrders.query()
  listOrders: procedure()
    .query(async ({ ctx }) => {
      const orders = await ctx.db.order.findMany();
      return resourceCollection(orders, OrderSchema.authenticated);
    }),
});
```

## Client Examples

### Mobile App (REST)

```swift
// iOS Swift
let url = URL(string: "http://api.example.com/api/orders")!
let (data, _) = try await URLSession.shared.data(from: url)
let orders = try JSONDecoder().decode([Order].self, from: data)
```

### Web Dashboard (tRPC)

```typescript
// React with tRPC
const { data: orders } = trpc.orders.listOrders.useQuery();
```

### Third-Party Integration (REST)

```bash
curl https://api.example.com/api/orders \
  -H "Authorization: Bearer ${API_KEY}"
```

## Selective Exposure

Procedures with recognized naming convention prefixes (e.g., `get*`, `list*`, `create*`) generate both tRPC and REST endpoints. Procedures without a recognized prefix are tRPC-only:

```typescript
// tRPC + REST (naming convention matches)
export const publicProcedures = procedures('status', {
  getStatus: procedure()
    .query(...),
  // → tRPC: trpc.status.getStatus
  // → REST:  GET /api/status/:id
});

// tRPC-only (no naming convention match)
export const internalProcedures = procedures('internal', {
  syncMetrics: procedure()
    .query(...),
  // → tRPC: trpc.internal.syncMetrics
  // → No REST endpoint generated
});
```

## Authentication Across Transports

The same guards work for both:

```typescript
const getOrder = procedure()
  .guard(authenticated)
  .input(z.object({ id: z.string() }))
  .query(...)

// REST: Authorization header
// tRPC: Same header or cookie
```

## API Versioning

For REST clients that need versioning:

```typescript
export const v1Procedures = procedures('v1/orders', {
  listOrders: procedure()...
});

export const v2Procedures = procedures('v2/orders', {
  listOrders: procedure()... // New shape
});
```

## Related Content

- [REST Conventions](/docs/router/rest-conventions/) - REST patterns
- [tRPC Adapter](/docs/router/trpc-adapter/) - tRPC configuration
- [OpenAPI](/docs/router/openapi/) - API documentation

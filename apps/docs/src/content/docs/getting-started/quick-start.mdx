---
title: Quick Start
description: Build your first VeloxTS API in 5 minutes.
---

import { Steps } from '@astrojs/starlight/components';

This guide walks you through creating a simple user API with VeloxTS.

<Steps>

1. **Create a new project**

   ```bash
   npx create-velox-app my-api
   cd my-api
   pnpm approve-builds  # Allow native module compilation (pnpm only)
   pnpm db:push
   ```

2. **Define your procedure**

   Edit `src/procedures/users.ts`:

   ```typescript
   import { procedures, procedure, resourceSchema, resource } from '@veloxts/velox';
   import { z } from '@veloxts/velox';

   // Define resource schema with field visibility
   const UserSchema = resourceSchema()
     .public('id', z.string())
     .public('name', z.string())
     .authenticated('email', z.string())
     .build();

   export const userProcedures = procedures('users', {
     // GET /api/users - public endpoint, manual projection
     listUsers: procedure()
       .query(async ({ ctx }) => {
         const users = await ctx.db.user.findMany();
         return users.map(user => resource(user, UserSchema.public));
       }),

     // GET /api/users/:id - public endpoint, manual projection
     getUser: procedure()
       .input(z.object({ id: z.string() }))
       .query(async ({ input, ctx }) => {
         const user = await ctx.db.user.findUniqueOrThrow({
           where: { id: input.id }
         });
         return resource(user, UserSchema.public);
       }),

     // POST /api/users - public endpoint
     createUser: procedure()
       .input(z.object({
         name: z.string().min(1),
         email: z.string().email(),
       }))
       .mutation(async ({ input, ctx }) => {
         const user = await ctx.db.user.create({ data: input });
         return resource(user, UserSchema.public);
       }),
   });
   ```

   For authenticated endpoints, use automatic projection with `.guardNarrow().resource()`:

   ```typescript
   import { authenticatedNarrow } from '@veloxts/auth';

   // Authenticated endpoint - auto-projects based on guard
   getProfile: procedure()
     .guardNarrow(authenticatedNarrow)
     .resource(UserSchema)
     .input(z.object({ id: z.string() }))
     .query(async ({ input, ctx }) => {
       // Just return data - projection is automatic!
       return ctx.db.user.findUniqueOrThrow({ where: { id: input.id } });
     }),
   ```

3. **Start the dev server**

   ```bash
   pnpm dev
   ```

4. **Test your API**

   ```bash
   # List users
   curl http://localhost:3030/api/users

   # Create a user
   curl -X POST http://localhost:3030/api/users \
     -H "Content-Type: application/json" \
     -d '{"name": "Alice", "email": "alice@example.com"}'

   # Get a user
   curl http://localhost:3030/api/users/1
   ```

</Steps>

## Understanding the Code

### Naming Conventions

VeloxTS uses procedure name prefixes to determine HTTP methods:

| Prefix | HTTP Method | Path |
|--------|-------------|------|
| `list*` | GET | `/api/{resource}` |
| `get*` | GET | `/api/{resource}/:id` |
| `create*` | POST | `/api/{resource}` |
| `update*` | PUT | `/api/{resource}/:id` |
| `delete*` | DELETE | `/api/{resource}/:id` |

See [REST Conventions](/docs/router/rest-conventions/) for the full list.

### Context (`ctx`)

Every procedure handler receives a `ctx` object containing:

- `ctx.db` - Prisma client for database access
- `ctx.request` - Fastify request object
- `ctx.reply` - Fastify reply object

## Related Content

- [Procedures](/docs/endpoints/procedures/) - Deep dive into the procedure API
- [Authentication](/docs/authentication/overview/) - Add login/logout
- [REST Conventions](/docs/router/rest-conventions/) - All naming patterns

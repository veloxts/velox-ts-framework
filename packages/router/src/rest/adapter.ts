/**
 * REST adapter for procedure collections
 *
 * Generates REST routes from procedure definitions using naming conventions
 * or manual overrides. Handles input validation, middleware execution, and
 * output serialization.
 *
 * @module rest/adapter
 */

import { type BaseContext, ConfigurationError } from '@veloxts/core';
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';

import { executeProcedure } from '../procedure/builder.js';
import type { CompiledProcedure, HttpMethod, ProcedureCollection } from '../types.js';
import { buildRestPath, parseNamingConvention } from './naming.js';

// ============================================================================
// Types
// ============================================================================

/**
 * REST route definition generated from a procedure
 */
export interface RestRoute {
  /** HTTP method */
  readonly method: HttpMethod;
  /** Full path including namespace prefix */
  readonly path: string;
  /** Procedure name for debugging */
  readonly procedureName: string;
  /** The compiled procedure */
  readonly procedure: CompiledProcedure;
}

/**
 * Options for REST route registration
 */
export interface RestAdapterOptions {
  /** API prefix (default: '/api') */
  prefix?: string;
  /** Custom error handler */
  onError?: (error: unknown, request: FastifyRequest, reply: FastifyReply) => void;
}

// ============================================================================
// Route Generation
// ============================================================================

/**
 * Generate REST routes from a procedure collection
 *
 * Routes are generated by:
 * 1. Using manual .rest() override if provided
 * 2. Inferring from naming convention (getX, listX, createX)
 * 3. Skipping if neither applies (tRPC-only procedure)
 *
 * @param collection - Procedure collection to generate routes from
 * @returns Array of REST route definitions
 */
export function generateRestRoutes(collection: ProcedureCollection): RestRoute[] {
  const routes: RestRoute[] = [];

  for (const [name, procedure] of Object.entries(collection.procedures)) {
    const route = generateRouteForProcedure(name, procedure, collection.namespace);
    if (route) {
      routes.push(route);
    }
  }

  return routes;
}

/**
 * Generate a REST route for a single procedure
 *
 * @internal
 */
function generateRouteForProcedure(
  name: string,
  procedure: CompiledProcedure,
  namespace: string
): RestRoute | undefined {
  // Check for manual REST override first
  if (procedure.restOverride) {
    const override = procedure.restOverride;

    // Must have both method and path for override
    if (override.method && override.path) {
      return {
        method: override.method,
        path: override.path,
        procedureName: name,
        procedure,
      };
    }

    // Partial override - try to fill in missing parts from convention
    const convention = parseNamingConvention(name, procedure.type);
    if (convention) {
      return {
        method: override.method ?? convention.method,
        path: override.path ?? buildRestPath(namespace, convention),
        procedureName: name,
        procedure,
      };
    }

    // Can't generate route without full info
    return undefined;
  }

  // Try to infer from naming convention
  const mapping = parseNamingConvention(name, procedure.type);
  if (mapping) {
    return {
      method: mapping.method,
      path: buildRestPath(namespace, mapping),
      procedureName: name,
      procedure,
    };
  }

  // No route for this procedure (tRPC-only)
  return undefined;
}

// ============================================================================
// Route Handler Creation
// ============================================================================

/**
 * Create a Fastify route handler from a procedure
 *
 * The handler:
 * 1. Extracts input from request (params, query, body)
 * 2. Gets context from request decorator
 * 3. Executes the procedure (validation, middleware, handler)
 * 4. Sets appropriate HTTP status code
 * 5. Returns the result
 */
function createRouteHandler(
  route: RestRoute
): (request: FastifyRequest, reply: FastifyReply) => Promise<unknown> {
  return async (request: FastifyRequest, reply: FastifyReply): Promise<unknown> => {
    // Gather input from appropriate sources based on method
    const input = gatherInput(request, route);

    // Get context from request (decorated by @veloxts/core)
    const ctx = getContextFromRequest(request);

    // Execute the procedure
    const result = await executeProcedure(route.procedure, input, ctx);

    // Set appropriate HTTP status codes based on method and result
    switch (route.method) {
      case 'POST':
        // 201 Created for new resources
        if (route.procedureName.startsWith('create') || route.procedureName.startsWith('add')) {
          reply.status(201);
        }
        break;

      case 'DELETE':
        // 204 No Content if result is null/undefined/empty, otherwise 200 OK
        if (result === null || result === undefined) {
          reply.status(204);
          return null;
        }
        break;

      // GET, PUT, PATCH default to 200 OK (Fastify default)
    }

    return result;
  };
}

/**
 * Type guard to check if a value is a plain object
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

/**
 * Gather input data from the request based on HTTP method
 *
 * - GET: Merge params and query
 * - POST: Use body
 * - PUT/PATCH: Merge params (for ID) and body (for data)
 * - DELETE: Merge params and query (no body per REST conventions)
 */
function gatherInput(request: FastifyRequest, route: RestRoute): unknown {
  const params = isPlainObject(request.params) ? request.params : {};
  const query = isPlainObject(request.query) ? request.query : {};
  const body = isPlainObject(request.body) ? request.body : {};

  switch (route.method) {
    case 'GET':
      // GET: params (for :id) + query (for filters/pagination)
      return { ...params, ...query };

    case 'DELETE':
      // DELETE: params (for :id) + query (for options), no body per REST conventions
      return { ...params, ...query };

    case 'PUT':
    case 'PATCH':
      // PUT/PATCH: params (for :id) + body (for data)
      return { ...params, ...body };

    case 'POST':
    default:
      // POST: body only (no ID in params for creates)
      return request.body;
  }
}

/**
 * Extract context from Fastify request
 *
 * The context is decorated onto the request by @veloxts/core's onRequest hook.
 * This function expects the context to already be present.
 */
function getContextFromRequest(request: FastifyRequest): BaseContext {
  // Type assertion is safe because @veloxts/core decorates this in onRequest hook
  const requestWithContext = request as FastifyRequest & { context: BaseContext };

  // The context should always be present if @veloxts/core is properly initialized
  // If it's not, we throw an error to help developers debug
  if (!requestWithContext.context) {
    throw new ConfigurationError(
      'Request context not found. Ensure VeloxApp is started before registering routes.'
    );
  }

  return requestWithContext.context;
}

// ============================================================================
// Route Registration
// ============================================================================

/**
 * Register REST routes from procedure collections onto a Fastify instance
 *
 * @param server - Fastify instance to register routes on
 * @param collections - Array of procedure collections
 * @param options - Registration options
 *
 * @example
 * ```typescript
 * import { createVeloxApp } from '@veloxts/core';
 * import { registerRestRoutes, defineProcedures, procedure } from '@veloxts/router';
 *
 * const app = await createVeloxApp();
 *
 * const users = defineProcedures('users', {
 *   getUser: procedure()
 *     .input(z.object({ id: z.string() }))
 *     .query(async ({ input }) => ({ id: input.id, name: 'John' })),
 *
 *   listUsers: procedure()
 *     .query(async () => [{ id: '1', name: 'John' }]),
 *
 *   createUser: procedure()
 *     .input(z.object({ name: z.string() }))
 *     .mutation(async ({ input }) => ({ id: 'new', name: input.name })),
 * });
 *
 * registerRestRoutes(app.server, [users], { prefix: '/api' });
 *
 * // Generates:
 * // GET  /api/users/:id  -> getUser
 * // GET  /api/users      -> listUsers
 * // POST /api/users      -> createUser
 * ```
 */
export function registerRestRoutes(
  server: FastifyInstance,
  collections: ProcedureCollection[],
  options: RestAdapterOptions = {}
): void {
  const { prefix = '/api' } = options;

  for (const collection of collections) {
    const routes = generateRestRoutes(collection);

    for (const route of routes) {
      const fullPath = `${prefix}${route.path}`;
      const handler = createRouteHandler(route);

      // Register route based on method
      switch (route.method) {
        case 'GET':
          server.get(fullPath, handler);
          break;
        case 'POST':
          server.post(fullPath, handler);
          break;
        case 'PUT':
          server.put(fullPath, handler);
          break;
        case 'PATCH':
          server.patch(fullPath, handler);
          break;
        case 'DELETE':
          server.delete(fullPath, handler);
          break;
      }
    }
  }
}

/**
 * Get a summary of routes that would be generated from collections
 *
 * Useful for debugging and documentation.
 *
 * @param collections - Procedure collections to analyze
 * @param prefix - API prefix (default: '/api')
 * @returns Array of route summaries
 */
export function getRouteSummary(
  collections: ProcedureCollection[],
  prefix = '/api'
): Array<{ method: HttpMethod; path: string; procedure: string; namespace: string }> {
  const summaries: Array<{
    method: HttpMethod;
    path: string;
    procedure: string;
    namespace: string;
  }> = [];

  for (const collection of collections) {
    const routes = generateRestRoutes(collection);

    for (const route of routes) {
      summaries.push({
        method: route.method,
        path: `${prefix}${route.path}`,
        procedure: route.procedureName,
        namespace: collection.namespace,
      });
    }
  }

  return summaries;
}

/**
 * Creates a route registrar function for use with VeloxApp.routes()
 *
 * This is a convenience helper that returns a function suitable for
 * passing to app.routes(), enabling a cleaner API.
 *
 * @param collections - Procedure collections to register
 * @param options - Registration options
 * @returns A function that registers routes on a Fastify instance
 *
 * @example
 * ```typescript
 * import { createVeloxApp } from '@veloxts/core';
 * import { createRoutesRegistrar, defineProcedures, procedure } from '@veloxts/router';
 *
 * const users = defineProcedures('users', {
 *   listUsers: procedure().query(async () => []),
 * });
 *
 * const app = await createVeloxApp();
 *
 * app.routes(createRoutesRegistrar([users], { prefix: '/api' }));
 *
 * await app.start();
 * ```
 */
export function createRoutesRegistrar(
  collections: ProcedureCollection[],
  options: RestAdapterOptions = {}
): (server: FastifyInstance) => void {
  return (server: FastifyInstance) => {
    registerRestRoutes(server, collections, options);
  };
}

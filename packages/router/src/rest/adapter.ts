/**
 * REST adapter for procedure collections
 *
 * Generates REST routes from procedure definitions using naming conventions
 * or manual overrides. Handles input validation, middleware execution, and
 * output serialization.
 *
 * @module rest/adapter
 */

import { type BaseContext, ConfigurationError } from '@veloxts/core';
import type { FastifyInstance, FastifyPluginAsync, FastifyReply, FastifyRequest } from 'fastify';

import { executeProcedure } from '../procedure/builder.js';
import type { CompiledProcedure, HttpMethod, ProcedureCollection } from '../types.js';
import type { RestMapping } from './naming.js';
import {
  buildMultiLevelNestedPath,
  buildNestedRestPath,
  buildRestPath,
  calculateNestingDepth,
  parseNamingConvention,
} from './naming.js';

// ============================================================================
// Types
// ============================================================================

/**
 * REST route definition generated from a procedure
 */
export interface RestRoute {
  /** HTTP method */
  readonly method: HttpMethod;
  /** Full path including namespace prefix */
  readonly path: string;
  /** Procedure name for debugging */
  readonly procedureName: string;
  /** The compiled procedure */
  readonly procedure: CompiledProcedure;
}

/**
 * Options for REST route registration
 *
 * When using `server.register(rest(...), options)`, the `prefix` option is
 * handled by Fastify's built-in prefix mechanism. When using the legacy
 * `rest(...)(server)` pattern, the prefix is applied manually.
 */
export interface RestAdapterOptions {
  /**
   * API prefix for routes.
   *
   * - With `server.register()`: Use Fastify's built-in prefix option instead
   * - With legacy `rest(...)(server)`: Prefix is applied manually (default: '/api')
   *
   * @default '/api' (legacy mode only)
   */
  prefix?: string;
  /** Custom error handler */
  onError?: (error: unknown, request: FastifyRequest, reply: FastifyReply) => void;
  /**
   * Generate flat routes alongside nested routes for easier access.
   *
   * When enabled, nested routes like `/organizations/:orgId/projects/:projectId/tasks/:id`
   * will also generate a flat shortcut route like `/tasks/:id`.
   *
   * Note: Flat routes only work for single-resource operations (GET, PUT, PATCH, DELETE with :id).
   * Collection operations (list, create) require parent context and are NOT generated as flat routes.
   *
   * @example
   * ```typescript
   * rest([tasks], { flatAccess: true })
   * // Generates:
   * // GET /organizations/:orgId/projects/:projectId/tasks/:id (nested)
   * // GET /tasks/:id (flat shortcut)
   * ```
   *
   * @default false
   */
  flatAccess?: boolean;
  /**
   * Suppress warnings about deep nesting (3+ levels).
   *
   * By default, the router warns when nesting exceeds 3 levels.
   * Set this to true to disable those warnings.
   *
   * @default false
   */
  suppressNestingWarnings?: boolean;
}

/**
 * Internal options used during route registration
 * @internal
 */
interface InternalRegistrationOptions extends RestAdapterOptions {
  /**
   * When true, the prefix is handled by Fastify's register() mechanism
   * and should not be manually prepended to routes.
   */
  _prefixHandledByFastify?: boolean;
}

// ============================================================================
// Route Generation
// ============================================================================

/** Options for generating REST routes */
export interface GenerateRestRoutesOptions {
  /** Generate flat routes alongside nested routes */
  flatAccess?: boolean;
  /** Suppress nesting depth warnings */
  suppressNestingWarnings?: boolean;
}

/** Default nesting depth threshold for warnings */
const NESTING_DEPTH_WARNING_THRESHOLD = 3;

/**
 * Generate REST routes from a procedure collection
 *
 * Routes are generated by:
 * 1. Using manual .rest() override if provided
 * 2. Inferring from naming convention (getX, listX, createX)
 * 3. Skipping if neither applies (tRPC-only procedure)
 *
 * @param collection - Procedure collection to generate routes from
 * @param options - Optional route generation options
 * @returns Array of REST route definitions
 */
export function generateRestRoutes(
  collection: ProcedureCollection,
  options: GenerateRestRoutesOptions = {}
): RestRoute[] {
  const routes: RestRoute[] = [];
  const { flatAccess = false, suppressNestingWarnings = false } = options;

  for (const [name, procedure] of Object.entries(collection.procedures)) {
    const route = generateRouteForProcedure(name, procedure, collection.namespace);
    if (route) {
      routes.push(route);

      // Check nesting depth and warn if too deep
      if (!suppressNestingWarnings) {
        const depth = calculateNestingDepth(procedure.parentResource, procedure.parentResources);
        if (depth >= NESTING_DEPTH_WARNING_THRESHOLD) {
          console.warn(
            `⚠️  Resource '${collection.namespace}/${name}' has ${depth} levels of nesting. ` +
              `Consider using flatAccess: true or restructuring your API.`
          );
        }
      }

      // Generate flat route if enabled and route is nested with ID parameter
      if (flatAccess && isNestedRoute(procedure) && route.path.endsWith('/:id')) {
        const flatRoute = generateFlatRoute(route, collection.namespace);
        if (flatRoute) {
          routes.push(flatRoute);
        }
      }
    }
  }

  return routes;
}

/**
 * Check if a procedure has parent resources (is nested)
 */
function isNestedRoute(procedure: CompiledProcedure): boolean {
  return (
    procedure.parentResource !== undefined ||
    (procedure.parentResources !== undefined && procedure.parentResources.length > 0)
  );
}

/**
 * Generate a flat route for a nested route
 *
 * Only generates flat routes for single-resource operations (with :id).
 * Collection operations require parent context and are not suitable for flat access.
 */
function generateFlatRoute(nestedRoute: RestRoute, namespace: string): RestRoute | undefined {
  // Only generate flat routes for operations with :id (single resource)
  if (!nestedRoute.path.endsWith('/:id')) {
    return undefined;
  }

  // Build flat path: /{namespace}/:id
  const flatPath = `/${namespace}/:id`;

  return {
    method: nestedRoute.method,
    path: flatPath,
    procedureName: `${nestedRoute.procedureName}Flat`,
    procedure: nestedRoute.procedure,
  };
}

/**
 * Build the REST path for a procedure based on its nesting configuration
 *
 * Handles:
 * - Flat routes: /users/:id
 * - Single-level nested: /posts/:postId/comments/:id
 * - Multi-level nested: /organizations/:orgId/projects/:projectId/tasks/:id
 *
 * @internal
 */
function buildProcedurePath(
  procedure: CompiledProcedure,
  namespace: string,
  mapping: RestMapping
): string {
  // Multi-level nesting takes precedence
  if (procedure.parentResources && procedure.parentResources.length > 0) {
    return buildMultiLevelNestedPath(procedure.parentResources, namespace, mapping);
  }

  // Single-level nesting
  if (procedure.parentResource) {
    return buildNestedRestPath(procedure.parentResource, namespace, mapping);
  }

  // Flat route
  return buildRestPath(namespace, mapping);
}

/**
 * Generate a REST route for a single procedure
 *
 * Handles flat routes (e.g., /users/:id), single-level nested routes
 * (e.g., /posts/:postId/comments/:id), and multi-level nested routes
 * (e.g., /organizations/:orgId/projects/:projectId/tasks/:id).
 *
 * @internal
 */
function generateRouteForProcedure(
  name: string,
  procedure: CompiledProcedure,
  namespace: string
): RestRoute | undefined {
  // Check for manual REST override first
  if (procedure.restOverride) {
    const override = procedure.restOverride;

    // Must have both method and path for override
    if (override.method && override.path) {
      // For manual overrides with full path, use as-is
      // The user is responsible for including parent segments if needed
      return {
        method: override.method,
        path: override.path,
        procedureName: name,
        procedure,
      };
    }

    // Partial override - try to fill in missing parts from convention
    const convention = parseNamingConvention(name, procedure.type);
    if (convention) {
      // Build path based on nesting configuration
      const path = override.path ?? buildProcedurePath(procedure, namespace, convention);

      return {
        method: override.method ?? convention.method,
        path,
        procedureName: name,
        procedure,
      };
    }

    // Can't generate route without full info
    return undefined;
  }

  // Try to infer from naming convention
  const mapping = parseNamingConvention(name, procedure.type);
  if (mapping) {
    // Build path based on nesting configuration
    const path = buildProcedurePath(procedure, namespace, mapping);

    return {
      method: mapping.method,
      path,
      procedureName: name,
      procedure,
    };
  }

  // No route for this procedure (tRPC-only)
  return undefined;
}

// ============================================================================
// Route Handler Creation
// ============================================================================

/**
 * Create a Fastify route handler from a procedure
 *
 * The handler:
 * 1. Extracts input from request (params, query, body)
 * 2. Gets context from request decorator
 * 3. Executes the procedure (validation, middleware, handler)
 * 4. Sets appropriate HTTP status code
 * 5. Returns the result
 */
function createRouteHandler(
  route: RestRoute
): (request: FastifyRequest, reply: FastifyReply) => Promise<unknown> {
  return async (request: FastifyRequest, reply: FastifyReply): Promise<unknown> => {
    // Gather input from appropriate sources based on method
    const input = gatherInput(request, route);

    // Get context from request (decorated by @veloxts/core)
    const ctx = getContextFromRequest(request);

    // Execute the procedure
    const result = await executeProcedure(route.procedure, input, ctx);

    // Set appropriate HTTP status codes based on method and result
    switch (route.method) {
      case 'POST':
        // 201 Created for new resources
        if (route.procedureName.startsWith('create') || route.procedureName.startsWith('add')) {
          reply.status(201);
        }
        break;

      case 'DELETE':
        // 204 No Content if result is null/undefined/empty, otherwise 200 OK
        if (result === null || result === undefined) {
          reply.status(204);
          return null;
        }
        break;

      // GET, PUT, PATCH default to 200 OK (Fastify default)
    }

    return result;
  };
}

/**
 * Type guard to check if a value is a plain object
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

/**
 * Gather input data from the request based on HTTP method
 *
 * - GET: Merge params and query
 * - POST: Use body, but merge params for nested routes (parent IDs in URL)
 * - PUT/PATCH: Merge params (for ID) and body (for data)
 * - DELETE: Merge params and query (no body per REST conventions)
 *
 * For nested routes (e.g., /posts/:postId/comments or
 * /organizations/:orgId/projects/:projectId/tasks), all parent params
 * are extracted from the URL and merged with the body/query as appropriate.
 */
function gatherInput(request: FastifyRequest, route: RestRoute): unknown {
  const params = isPlainObject(request.params) ? request.params : {};
  const query = isPlainObject(request.query) ? request.query : {};
  const body = isPlainObject(request.body) ? request.body : {};

  // Check if this is a nested route (has single parent or multiple parents)
  const hasParentResource =
    route.procedure.parentResource !== undefined ||
    (route.procedure.parentResources !== undefined && route.procedure.parentResources.length > 0);

  switch (route.method) {
    case 'GET':
      // GET: params (for :id and all parent params) + query (for filters/pagination)
      return { ...params, ...query };

    case 'DELETE':
      // DELETE: params (for :id and all parent params) + query (for options), no body per REST conventions
      return { ...params, ...query };

    case 'PUT':
    case 'PATCH':
      // PUT/PATCH: params (for :id and all parent params) + body (for data)
      return { ...params, ...body };

    case 'POST':
      // POST: For nested routes, merge params (for all parent IDs) with body
      // For flat routes, use body only (no ID in params for creates)
      if (hasParentResource) {
        return { ...params, ...body };
      }
      return request.body;

    default:
      return request.body;
  }
}

/**
 * Extract context from Fastify request
 *
 * The context is decorated onto the request by @veloxts/core's onRequest hook.
 * This function expects the context to already be present and also merges
 * any auth properties added by @veloxts/auth's preHandler hook.
 */
function getContextFromRequest(request: FastifyRequest): BaseContext {
  // Type assertion is safe because @veloxts/core decorates this in onRequest hook
  const requestWithContext = request as FastifyRequest & {
    context: BaseContext;
    auth?: unknown;
    user?: unknown;
  };

  // The context should always be present if @veloxts/core is properly initialized
  // If it's not, we throw an error to help developers debug
  if (!requestWithContext.context) {
    throw new ConfigurationError(
      'Request context not found. Ensure VeloxApp is started before registering routes.'
    );
  }

  // Merge auth properties from request if @veloxts/auth has added them
  // This allows guards to access ctx.auth and ctx.user
  const context = requestWithContext.context;
  if (requestWithContext.auth !== undefined || requestWithContext.user !== undefined) {
    return {
      ...context,
      auth: requestWithContext.auth,
      user: requestWithContext.user,
    } as BaseContext;
  }

  return context;
}

// ============================================================================
// Route Registration
// ============================================================================

/**
 * Register REST routes from procedure collections onto a Fastify instance
 *
 * @param server - Fastify instance to register routes on
 * @param collections - Array of procedure collections
 * @param options - Registration options
 *
 * @example
 * ```typescript
 * import { createVeloxApp } from '@veloxts/core';
 * import { registerRestRoutes, defineProcedures, procedure } from '@veloxts/router';
 *
 * const app = await createVeloxApp();
 *
 * const users = defineProcedures('users', {
 *   getUser: procedure()
 *     .input(z.object({ id: z.string() }))
 *     .query(async ({ input }) => ({ id: input.id, name: 'John' })),
 *
 *   listUsers: procedure()
 *     .query(async () => [{ id: '1', name: 'John' }]),
 *
 *   createUser: procedure()
 *     .input(z.object({ name: z.string() }))
 *     .mutation(async ({ input }) => ({ id: 'new', name: input.name })),
 * });
 *
 * registerRestRoutes(app.server, [users], { prefix: '/api' });
 *
 * // Generates:
 * // GET  /api/users/:id  -> getUser
 * // GET  /api/users      -> listUsers
 * // POST /api/users      -> createUser
 * ```
 */
export function registerRestRoutes(
  server: FastifyInstance,
  collections: ProcedureCollection[],
  options: InternalRegistrationOptions = {}
): void {
  const {
    prefix = '/api',
    _prefixHandledByFastify = false,
    flatAccess = false,
    suppressNestingWarnings = false,
  } = options;

  const routeGenOptions: GenerateRestRoutesOptions = {
    flatAccess,
    suppressNestingWarnings,
  };

  for (const collection of collections) {
    const routes = generateRestRoutes(collection, routeGenOptions);

    for (const route of routes) {
      // When used with server.register(), Fastify handles the prefix automatically.
      // When used in legacy mode, we prepend the prefix manually.
      const fullPath = _prefixHandledByFastify ? route.path : `${prefix}${route.path}`;
      const handler = createRouteHandler(route);

      // Register route based on method
      switch (route.method) {
        case 'GET':
          server.get(fullPath, handler);
          break;
        case 'POST':
          server.post(fullPath, handler);
          break;
        case 'PUT':
          server.put(fullPath, handler);
          break;
        case 'PATCH':
          server.patch(fullPath, handler);
          break;
        case 'DELETE':
          server.delete(fullPath, handler);
          break;
      }
    }
  }
}

/**
 * Get a summary of routes that would be generated from collections
 *
 * Useful for debugging and documentation.
 *
 * @param collections - Procedure collections to analyze
 * @param prefix - API prefix (default: '/api')
 * @returns Array of route summaries
 */
export function getRouteSummary(
  collections: ProcedureCollection[],
  prefix = '/api'
): Array<{ method: HttpMethod; path: string; procedure: string; namespace: string }> {
  const summaries: Array<{
    method: HttpMethod;
    path: string;
    procedure: string;
    namespace: string;
  }> = [];

  for (const collection of collections) {
    const routes = generateRestRoutes(collection);

    for (const route of routes) {
      summaries.push({
        method: route.method,
        path: `${prefix}${route.path}`,
        procedure: route.procedureName,
        namespace: collection.namespace,
      });
    }
  }

  return summaries;
}

/**
 * A callable Fastify plugin type that supports dual-mode registration:
 * - As a Fastify plugin: `server.register(rest([...]), { prefix: '/api' })`
 * - As a direct callable: `app.routes(rest([...]))` for VeloxApp
 */
export type RestPlugin = FastifyPluginAsync<RestAdapterOptions> &
  ((server: FastifyInstance) => void);

/**
 * Creates a Fastify plugin for REST endpoints from procedure collections.
 *
 * This is the preferred way to register procedure collections as REST routes.
 * The function returns a dual-mode plugin that works with both modern Fastify
 * `register()` pattern and the legacy `app.routes()` pattern.
 *
 * @param collections - Procedure collections to register as REST routes
 * @param defaultOptions - Default REST adapter options (can be overridden at registration)
 * @returns A Fastify plugin that can be used with `server.register()` or called directly
 *
 * @example Modern API (recommended)
 * ```typescript
 * import Fastify from 'fastify';
 * import { rest, defineProcedures, procedure } from '@veloxts/router';
 *
 * const users = defineProcedures('users', {
 *   listUsers: procedure().query(async () => []),
 *   createUser: procedure()
 *     .input(z.object({ name: z.string() }))
 *     .mutation(async ({ input }) => ({ id: '1', ...input })),
 * });
 *
 * const server = Fastify();
 *
 * // Register with Fastify's built-in prefix handling
 * await server.register(rest([users]), { prefix: '/api' });
 *
 * // Generates:
 * // GET  /api/users      -> listUsers
 * // POST /api/users      -> createUser
 * ```
 *
 * @example Legacy API (backward compatible)
 * ```typescript
 * import { veloxApp } from '@veloxts/core';
 * import { rest, defineProcedures, procedure } from '@veloxts/router';
 *
 * const app = await veloxApp();
 *
 * // Legacy registration with manual prefix
 * app.routes(rest([users], { prefix: '/api' }));
 *
 * await app.start();
 * ```
 *
 * @example Merging options
 * ```typescript
 * // Options passed to rest() are defaults
 * const plugin = rest([users], { onError: customHandler });
 *
 * // Options passed to register() override/merge with defaults
 * await server.register(plugin, { prefix: '/v1' });
 * ```
 */
export function rest(
  collections: ProcedureCollection[],
  defaultOptions: RestAdapterOptions = {}
): RestPlugin {
  /**
   * The async plugin function for Fastify's register() method.
   * When used with register(), Fastify handles the prefix automatically.
   */
  const plugin: FastifyPluginAsync<RestAdapterOptions> = async (
    instance: FastifyInstance,
    opts: RestAdapterOptions
  ): Promise<void> => {
    // Merge default options with options passed to register()
    // Options from register() take precedence
    const mergedOptions: InternalRegistrationOptions = {
      ...defaultOptions,
      ...opts,
      // When used via register(), Fastify handles the prefix automatically
      // We signal this to registerRestRoutes so it doesn't double-prefix
      _prefixHandledByFastify: true,
    };

    registerRestRoutes(instance, collections, mergedOptions);
  };

  /**
   * Create a callable wrapper that supports both patterns:
   * 1. As a Fastify plugin: server.register(rest([...]), opts)
   * 2. As a direct call: rest([...])(server) - legacy pattern
   *
   * The trick is that FastifyPluginAsync expects (instance, opts) => Promise<void>
   * but the legacy pattern expects (server) => void.
   *
   * We detect which mode based on the second argument:
   * - If second arg is undefined/missing: legacy callable mode
   * - If second arg is present: Fastify plugin mode (called by register())
   */
  const dualModePlugin = (
    instance: FastifyInstance,
    opts?: RestAdapterOptions
  ): void | Promise<void> => {
    // If opts is provided, we're being called by Fastify's register()
    // In this case, return the promise from the async plugin
    if (opts !== undefined) {
      return plugin(instance, opts);
    }

    // Legacy mode: called directly as rest([...])(server)
    // Use default options and apply prefix manually
    registerRestRoutes(instance, collections, defaultOptions);
  };

  // Add plugin metadata for VeloxTS plugin validation
  // Note: Using Object.defineProperty to avoid TypeScript errors about function properties
  Object.defineProperty(dualModePlugin, Symbol.for('plugin-meta'), {
    value: true,
  });
  Object.defineProperty(dualModePlugin, Symbol.for('fastify.display-name'), {
    value: 'dualModePlugin',
  });
  Object.defineProperty(dualModePlugin, 'name', {
    value: 'dualModePlugin',
  });
  Object.defineProperty(dualModePlugin, 'version', {
    value: '1.0.0',
  });

  // Cast to RestPlugin - TypeScript needs help understanding this dual nature
  // The function satisfies both signatures:
  // - (instance, opts) => Promise<void> for Fastify register
  // - (server) => void for legacy callable
  return dualModePlugin as RestPlugin;
}
